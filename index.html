<!DOCTYPE html>
<html>
<head>
  <title>Kaleidoscope Drawing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: sans-serif;
      color: #fff;
      position: relative;
    }
    canvas {
      display: block;
      /* THIS IS THE CRUCIAL FIX: */
      pointer-events: none;
    }

    /* =========================
       SHARED/EXISTING UI
       ========================= */
    .param-table {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.3);
      padding: 8px; /* Adjusted padding */
      border-radius: 5px;
      font-size: 8px; /* Adjusted font size */
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: opacity 0.5s;
      width: 120px; /* Adjusted width */
    }
    .param-table.hidden, .controls-container.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .param-table table {
      border-collapse: collapse;
      width: 100%;
    }
    .param-table th, .param-table td {
      padding: 5px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .param-table th {
      background: rgba(0, 255, 0, 0.1);
      color: #fff;
    }
    .param-table td {
      background: rgba(0, 0, 0, 0.2);
    }
    .controls-container {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 9;
    }
    .controls-container > div {
      pointer-events: auto;
    }
    .controls-bottom-left, .controls-bottom-right {
      position: absolute;
      bottom: 20px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .controls-bottom-left {
      left: 20px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
    }
    .controls-bottom-right {
      right: 20px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
    }
    .controls-bottom-left button, .controls-bottom-right button, .mobile-sliders button, #play-pause-btn {
      padding: 8px 12px;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.5);
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.3s;
    }
    .controls-bottom-right button {
      min-width: 150px;
    }
    .controls-bottom-left .full-width-btn, .mobile-sliders .full-width-btn {
      grid-column: span 2;
    }

    /* =========================
       MOBILE UI
       ========================= */

    .top-ui-container {
      position: absolute;
      top: 10px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 10px;
      box-sizing: border-box;
      z-index: 99; /* above everything */
      pointer-events: none; /* allows events to pass to canvas */
    }

    .toggle-ui-btn {
      pointer-events: auto; /* re-enables events for buttons */
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.5);
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      opacity: 0.9;
      transition: opacity 0.25s, transform 0.2s;
    }
    .toggle-ui-btn:active { transform: scale(0.98); }
    .toggle-ui-btn.hidden { display: none; }

    /* Mobile sliders panel (compact) */
    .mobile-sliders {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      display: none;        /* default hidden */
      flex-direction: column;
      gap: 8px;
      z-index: 25;          /* below toggle button */
      overflow-y: auto;
      max-height: 48vh;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }
    .mobile-sliders.hidden { display: none; }

    /* Compact slider rows */
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      line-height: 1;
    }
    .slider-container label {
      min-width: 92px;
      text-align: right;
      font-size: 12px;
      opacity: 0.95;
    }
    .slider-container input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #444;
      border-radius: 5px;
      outline: none;
    }
    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: #888;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(255,255,255,0.25);
    }
    .slider-container input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #888;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(255,255,255,0.25);
    }
    .slider-container span {
      min-width: 44px;
      text-align: left;
    }
    .mobile-buttons-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.15);
    }
    .mobile-buttons-container button {
      flex: 1;
      min-width: unset;
      font-size: 12px;
      padding: 6px 8px;
      white-space: nowrap;
    }

    /* NEW: Mobile button color states for wave mode */
    .mobile-buttons-container .is-on {
      background: rgba(0, 255, 0, 0.2);
    }
    .mobile-buttons-container .wave-in {
      background: rgba(255, 255, 0, 0.2);
    }
    .mobile-buttons-container .wave-out {
      background: rgba(255, 0, 0, 0.2);
    }
    .mobile-buttons-container .wave-off {
      background: transparent;
    }

    /* Hide desktop UI and show mobile button only on small screens */
    @media (max-width: 768px) {
      .controls-container, .param-table {
        display: none;
      }
      .mobile-sliders {
        display: flex; /* will be overridden by .hidden when needed */
      }
      /* The toggle button exists only on mobile */
      .top-ui-container {
        display: flex;
      }
      .toggle-ui-btn {
        display: block;
      }
    }

    /* On desktop, never show the mobile toggle */
    @media (min-width: 769px) {
      .top-ui-container, .toggle-ui-btn {
        display: none;
      }
    }
  </style>
</head>
<body>

<div id="debug-message-box" class="debug-message-box" style="position:absolute; top:0; left:0; z-index:50; font-size:11px; padding:4px 6px; color:#9cf;"></div>

<div class="top-ui-container">
  <button id="saveBtn" class="toggle-ui-btn" onclick="saveToHtmlFile()" title="Save Session">
    &#x1F4BE;
  </button>

  <button id="toggleBtn" class="toggle-ui-btn" onclick="toggleMobileUI()">
    Sliders
  </button>

  <button id="copyLinkBtn" class="toggle-ui-btn"
          onclick="navigator.clipboard.writeText(window.location.href.split('#')[0] + '#' + encodeURIComponent(JSON.stringify({
            positions, numSymmetry, baseSize, animSpeed, waveSpeed, breathingFreq,
            waveSpatialFreq, breathingAmp, colorShiftSpeed, pulseMin, breathingOn,
            minDist, waveMode, hueVariationAmp, dynamicHue, sbsMode, sbsDistance, zoom,
            sunsetMode, overexposureThreshold
          }))).then(()=>{alert('Link copied!');})">
    Copy Link
  </button>

  <button
      id="fullscreenBtn"
      class="toggle-ui-btn"
      onclick="toggleFullScreen()"
      title="Full screen">
    &#x26F6;
  </button>
</div>


<div class="param-table" id="param-table">
  <table>
    <tr><th>Sym</th><td id="sym">6</td></tr>
    <tr><th>Size</th><td id="size">15</td></tr>
    <tr><th>Anim Spd</th><td id="animSpeed">0.030</td></tr>
    <tr><th>Wave Spd</th><td id="waveSpeed">3</td></tr>
    <tr><th>Breath Freq</th><td id="breathingFreq">0.3</td></tr>
    <tr><th>Wave Freq</th><td id="waveSpatialFreq">0.09</td></tr>
    <tr><th>Breath Amp</th><td id="breathingAmp">30</td></tr>
    <tr><th>Color Shift</th><td id="colorShiftSpeed">50</td></tr>
    <tr><th>Pulse Min</th><td id="pulseMin">0.2</td></tr>
    <tr><th>Spacing</th><td id="minDist">1</td></tr>
    <tr><th>Wave Mode</th><td id="waveMode">Both</td></tr>
    <tr><th>Hue Var Amp</th><td id="hueVariationAmp">5</td></tr>
    <tr><th>Dynamic Hue</th><td id="dynamicHue">ON</td></tr>
    <tr><th>SBS Mode</th><td id="sbsMode">OFF</td></tr>
    <tr><th>SBS Distance</th><td id="sbsDistance">0</td></tr>
    <tr><th>Zoom</th><td id="zoom">1.00</td></tr>
    <tr><th>Sunset Mode</th><td id="sunsetMode">OFF</td></tr>
    <tr><th>Overexp Thresh</th><td id="overexposureThreshold">0.90</td></tr>
  </table>
</div>

<div class="controls-container" id="controls-container">
  <div class="controls-bottom-left">
    <button onclick="changeParam('symmetry', -1)">Sym - [U]</button>
    <button onclick="changeParam('symmetry', 1)">Sym + [I]</button>
    <button onclick="changeParam('size', -5)">Size - [D]</button>
    <button onclick="changeParam('size', 5)">Size + [F]</button>
    <button onclick="changeParam('animSpeed', -0.005)">Anim Spd - [T]</button>
    <button onclick="changeParam('animSpeed', 0.005)">Anim Spd + [Y]</button>
    <button onclick="changeParam('waveSpeed', -1)">Wave Spd - [Q]</button>
    <button onclick="changeParam('waveSpeed', 1)">Wave Spd + [W]</button>
    <button onclick="toggleNormalDraw()" class="full-width-btn">Normal Draw - [K]</button>
  </div>
  <div class="controls-bottom-right">
    <button onclick="changeParam('breathingFreq', -0.1)">Breath Freq - [A]</button>
    <button onclick="changeParam('breathingFreq', 0.1)">Breath Freq + [S]</button>
    <button onclick="changeParam('waveSpatialFreq', -0.01)">Wave Freq - [E]</button>
    <button onclick="changeParam('waveSpatialFreq', 0.01)">Wave Freq + [R]</button>
    <button onclick="changeParam('breathingAmp', -10)">Breath Amp - [Z]</button>
    <button onclick="changeParam('breathingAmp', 10)">Breath Amp + [X]</button>
    <button onclick="changeParam('colorShiftSpeed', -10)">Color Shift - [G]</button>
    <button onclick="changeParam('colorShiftSpeed', 10)">Color Shift + [H]</button>
    <button onclick="changeParam('pulseMin', -0.1)">Pulse Min - [V]</button>
    <button onclick="changeParam('pulseMin', 0.1)">Pulse Min + [B]</button>
    <button onclick="changeParam('minDist', -1)">Spacing - [</button>
    <button onclick="changeParam('minDist', 1)">Spacing + ]</button>
    <button onclick="changeParam('hueVariationAmp', -1)">Hue Var - [N]</button>
    <button onclick="changeParam('hueVariationAmp', 1)">Hue Var + [M]</button>
    <button onclick="changeParam('sbsDistance', -10)">SBS Dist -</button>
    <button onclick="changeParam('sbsDistance', 10)">SBS Dist +</button>
    <button onclick="changeParam('zoom', -0.1)">Zoom -</button>
    <button onclick="changeParam('zoom', 0.1)">Zoom +</button>
    <button onclick="changeParam('overexposureThreshold', -0.05)">Overexp Thresh -</button>
    <button onclick="changeParam('overexposureThreshold', 0.05)">Overexp Thresh +</button>
    <button id="dynamicHueBtn" onclick="toggleDynamicHue()" class="full-width-btn">Dynamic Hue - ON [J]</button>
    <button id="waveModeBtn" onclick="changeParam('waveMode', 0)" class="full-width-btn">Wave Mode - Both [O]</button>
    <button id="toggleBreathingBtn" onclick="toggleBreathing()" class="full-width-btn">Breathing - ON [P]}</button>
    <button id="sbsModeBtn" onclick="toggleSBSMode()" class="full-width-btn">SBS Mode - OFF [L]}</button>
    <button id="sunsetModeBtn" onclick="toggleSunsetMode()" class="full-width-btn">Sunset Mode - OFF</button>
    <button onclick="resetSettings()" class="full-width-btn">Reset - [⌫]</button>
    <button onclick="toggleDesktopUI()" class="full-width-btn">Hide UI - [`]</button>
  </div>
</div>

<div class="mobile-sliders hidden" id="mobile-sliders">
  <div class="slider-container">
    <label>Symmetry</label>
    <input type="range" min="1" max="20" step="1" value="6" oninput="setParam('symmetry', this.value)">
    <span id="symmetry-value">6</span>
  </div>
  <div class="slider-container">
    <label>Size</label>
    <input type="range" min="5" max="50" step="5" value="15" oninput="setParam('size', this.value)">
    <span id="size-value">15</span>
  </div>
  <div class="slider-container">
    <label>Anim Spd</label>
    <input type="range" min="0.001" max="0.1" step="0.005" value="0.03" oninput="setParam('animSpeed', this.value)">
    <span id="animSpeed-value">0.030</span>
  </div>
  <div class="slider-container">
    <label>Wave Spd</label>
    <input type="range" min="1" max="10" step="1" value="3" oninput="setParam('waveSpeed', this.value)">
    <span id="waveSpeed-value">3</span>
  </div>
  <div class="slider-container">
    <label>Breath Freq</label>
    <input type="range" min="0.1" max="1" step="0.1" value="0.3" oninput="setParam('breathingFreq', this.value)">
    <span id="breathingFreq-value">0.3</span>
  </div>
  <div class="slider-container">
    <label>Wave Freq</label>
    <input type="range" min="0.01" max="0.5" step="0.01" value="0.09" oninput="setParam('waveSpatialFreq', this.value)">
    <span id="waveSpatialFreq-value">0.09</span>
  </div>
  <div class="slider-container">
    <label>Breath Amp</label>
    <input type="range" min="10" max="100" step="10" value="30" oninput="setParam('breathingAmp', this.value)">
    <span id="breathingAmp-value">30</span>
  </div>
  <div class="slider-container">
    <label>Color Shift</label>
    <input type="range" min="10" max="100" step="10" value="50" oninput="setParam('colorShiftSpeed', this.value)">
    <span id="colorShiftSpeed-value">50</span>
  </div>
  <div class="slider-container">
    <label>Pulse Min</label>
    <input type="range" min="0.1" max="0.9" step="0.1" value="0.2" oninput="setParam('pulseMin', this.value)">
    <span id="pulseMin-value">0.2</span>
  </div>
  <div class="slider-container">
    <label>Spacing</label>
    <input type="range" min="1" max="10" step="1" value="1" oninput="setParam('minDist', this.value)">
    <span id="minDist-value">1</span>
  </div>
  <div class="slider-container">
    <label>Hue Var Amp</label>
    <input type="range" min="0" max="20" step="1" value="5" oninput="setParam('hueVariationAmp', this.value)">
    <span id="hueVariationAmp-value">5</span>
  </div>
  <div class="slider-container">
    <label>SBS Dist</label>
    <input type="range" min="-300" max="300" step="10" value="0" oninput="setParam('sbsDistance', this.value)">
    <span id="sbsDistance-value">0</span>
  </div>
  <div class="slider-container">
    <label>Zoom</label>
    <input type="range" min="0.1" max="5.0" step="0.1" value="1.0" oninput="setParam('zoom', this.value)">
    <span id="zoom-value">1.0</span>
  </div>
  <div class="slider-container">
    <label>Overexp Thresh</label>
    <input type="range" min="0.1" max="1.0" step="0.05" value="0.9" oninput="setParam('overexposureThreshold', this.value)">
    <span id="overexposureThreshold-value">0.90</span>
  </div>

  <div class="mobile-buttons-container">
    <button id="mobileNormalDrawBtn" onclick="toggleNormalDraw()">Normal</button>
    <button id="mobileBreathingBtn" onclick="toggleBreathing()">Breathing</button>
    <button id="mobileWaveModeBtn" onclick="changeParam('waveMode', 0)">Wave</button>
    <button id="mobileDynamicHueBtn" onclick="toggleDynamicHue()">Dyn Hue</button>
    <button id="mobileSbsBtn" onclick="toggleSBSMode()">SBS Mode</button>
    <button id="mobileSunsetBtn" onclick="toggleSunsetMode()">Sunset</button>
    <button onclick="resetSettings()">Reset</button>
    <button onclick="clearDrawing()">Delete</button>
  </div>
</div>

<script>
// Prevent right-click context menu unless Ctrl is pressed
document.oncontextmenu = function(event) {
  return event.ctrlKey;
};

// =========================
// Global variables
// =========================
let numSymmetry;
let time = 0;
let positions = [];
let baseSize;
let animSpeed;
let waveSpeed;
let breathingFreq;
let waveSpatialFreq;
let breathingAmp;
let colorShiftSpeed;
let pulseMin;
let breathingOn;
let lastSymmetry;
let minDist;
let isDesktopUIVisible = true; // NEW: Default to true
let isMobileUIVisible = false;
let waveMode;
let hueVariationAmp;
let dynamicHue;
let sbsMode;
let sbsDistance;
let zoom;
let sunsetMode;
let overexposureThreshold; // NEW: Overexposure Threshold

// Mobile auto-hide timer
let hideUITimer = null;

// Default settings
const defaultSettings = {
  numSymmetry: 6,
  waveSpeed: 3,
  breathingFreq: 0.3,
  breathingAmp: 30,
  waveSpatialFreq: 0.09,
  pulseMin: 0.2,
  minDist: 1,
  baseSize: 15,
  animSpeed: 0.03,
  colorShiftSpeed: 50,
  waveMode: 'both',
  hueVariationAmp: 5,
  dynamicHue: true,
  sbsMode: false,
  sbsDistance: 0,
  zoom: 1.0,
  nonGreenHues: [0, 30, 60, 200, 240, 300], // Red, orange, yellow, cyan, blue, purple
  // UPDATED: Sunset hues now contain only the vibrant colors
  sunsetHues: [0, 15, 30, 60, 240, 270, 300, 330],
  overexposureThreshold: 0.9
};

/* --- Debugging: console only --- */
function debugMessage(msg) {
  console.log(msg); // no more drawing text to canvas
}

/* --- Key handling --- */
document.addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.key.toLowerCase() === 's') {
    event.preventDefault();
    saveToHtmlFile(); // This already calls the function that creates the timestamped filename
    return;
  }

  if (event.key === 'Delete') {
    clearDrawing(); // Call new function
    return;
  }

  const key = event.key.toUpperCase();
  switch (key) {
    case 'Q': changeParam('waveSpeed', -1); break;
    case 'W': changeParam('waveSpeed', 1); break;
    case 'A': changeParam('breathingFreq', -0.1); break;
    case 'S': changeParam('breathingFreq', 0.1); break;
    case 'Z': changeParam('breathingAmp', -10); break;
    case 'X': changeParam('breathingAmp', 10); break;
    case 'E': changeParam('waveSpatialFreq', -0.01); break;
    case 'R': changeParam('waveSpatialFreq', 0.01); break;
    case 'D': changeParam('size', -5); break;
    case 'F': changeParam('size', 5); break;
    case 'T': changeParam('animSpeed', -0.005); break;
    case 'Y': changeParam('animSpeed', 0.005); break;
    case 'G': changeParam('colorShiftSpeed', -10); break;
    case 'H': changeParam('colorShiftSpeed', 10); break;
    case 'V': changeParam('pulseMin', -0.1); break;
    case 'B': changeParam('pulseMin', 0.1); break;
    case '[': changeParam('minDist', -1); break;
    case ']': changeParam('minDist', 1); break;
    case 'U': changeParam('symmetry', -1); break;
    case 'I': changeParam('symmetry', 1); break;
    case 'N': changeParam('hueVariationAmp', -1); break;
    case 'M': changeParam('hueVariationAmp', 1); break;
    case 'J': toggleDynamicHue(); break;
    case 'O': changeParam('waveMode', 0); break;
    case 'P': toggleBreathing(); break;
    case 'L': toggleSBSMode(); break;
    case '`':
      toggleDesktopUI();
      toggleMobileUI();
      break;
    case 'BACKSPACE': resetSettings(); break;
  }
});

// =========================
// Desktop UI toggle (unchanged logic; no mobile button involvement)
// =========================
function toggleDesktopUI() {
  const controlsContainer = document.getElementById('controls-container');
  const paramTable = document.getElementById('param-table');
  isDesktopUIVisible = !isDesktopUIVisible;
  if (isDesktopUIVisible) {
    controlsContainer.classList.remove('hidden');
    paramTable.classList.remove('hidden');
  } else {
    controlsContainer.classList.add('hidden');
    paramTable.classList.add('hidden');
  }
}

// =========================
// Mobile UI show/hide + inactivity auto-hide
// =========================
function toggleMobileUI() {
  const mobileSliders = document.getElementById('mobile-sliders');
  isMobileUIVisible = !isMobileUIVisible;
  if (isMobileUIVisible) {
    mobileSliders.classList.remove('hidden');
  } else {
    mobileSliders.classList.add('hidden');
  }
  resetHideUITimer();
}

function showMobileButton() {
  const topButtons = document.querySelectorAll('.top-ui-container .toggle-ui-btn');
  topButtons.forEach(btn => btn.classList.remove('hidden'));
}

function hideMobileUICompletely() {
  const mobileSliders = document.getElementById('mobile-sliders');
  const topButtons = document.querySelectorAll('.top-ui-container .toggle-ui-btn');
  mobileSliders.classList.add('hidden');
  topButtons.forEach(btn => btn.classList.add('hidden'));
  isMobileUIVisible = false;
}

function resetHideUITimer() {
  clearTimeout(hideUITimer);
  hideUITimer = setTimeout(() => {
    hideMobileUICompletely();
  }, 3000); // 3 seconds
}

// =========================
// p5 setup/draw
// =========================
function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  background(0);

  // 1. Try to restore state from URL
  const hash = window.location.hash.substring(1);
  debugMessage('Checking URL...');
  let restored = false;
  if (hash) {
    try {
      const state = JSON.parse(decodeURIComponent(hash));
      if (state.positions) positions = state.positions;
      if (state.numSymmetry !== undefined) numSymmetry = state.numSymmetry;
      if (state.baseSize !== undefined) baseSize = state.baseSize;
      if (state.animSpeed !== undefined) animSpeed = state.animSpeed;
      if (state.waveSpeed !== undefined) waveSpeed = state.waveSpeed;
      if (state.breathingFreq !== undefined) breathingFreq = state.breathingFreq;
      if (state.waveSpatialFreq !== undefined) waveSpatialFreq = state.waveSpatialFreq;
      if (state.breathingAmp !== undefined) breathingAmp = state.breathingAmp;
      if (state.colorShiftSpeed !== undefined) colorShiftSpeed = state.colorShiftSpeed;
      if (state.pulseMin !== undefined) pulseMin = state.pulseMin;
      if (state.breathingOn !== undefined) breathingOn = state.breathingOn;
      if (state.minDist !== undefined) minDist = state.minDist;
      if (state.waveMode !== undefined) waveMode = state.waveMode;
      if (state.hueVariationAmp !== undefined) hueVariationAmp = state.hueVariationAmp;
      if (state.dynamicHue !== undefined) dynamicHue = state.dynamicHue;
      if (state.sbsMode !== undefined) sbsMode = state.sbsMode;
      if (state.sbsDistance !== undefined) sbsDistance = state.sbsDistance;
      if (state.zoom !== undefined) zoom = state.zoom;
      if (state.sunsetMode !== undefined) sunsetMode = state.sunsetMode;
      if (state.overexposureThreshold !== undefined) overexposureThreshold = state.overexposureThreshold;
      restored = true;
      debugMessage('State loaded from URL!');
    } catch (e) {
      console.error("Failed to parse state from URL:", e);
      debugMessage('ERROR: Could not load state from URL.');
    }
  }

  // 2. If nothing was restored, reset to defaults
  if (!restored) {
    debugMessage('No saved state found. Starting new session.');
    resetSettings();
  }

  // 3. Ensure all variables exist after potential restoration
  numSymmetry ??= defaultSettings.numSymmetry;
  waveSpeed ??= defaultSettings.waveSpeed;
  breathingFreq ??= defaultSettings.breathingFreq;
  breathingAmp ??= defaultSettings.breathingAmp;
  waveSpatialFreq ??= defaultSettings.waveSpatialFreq;
  pulseMin ??= defaultSettings.pulseMin;
  minDist ??= defaultSettings.minDist;
  baseSize ??= defaultSettings.baseSize;
  animSpeed ??= defaultSettings.animSpeed;
  colorShiftSpeed ??= defaultSettings.colorShiftSpeed;
  breathingOn ??= true;
  waveMode ??= defaultSettings.waveMode;
  hueVariationAmp ??= defaultSettings.hueVariationAmp;
  dynamicHue ??= defaultSettings.dynamicHue;
  sbsMode ??= defaultSettings.sbsMode;
  sbsDistance ??= defaultSettings.sbsDistance;
  zoom ??= defaultSettings.zoom;
  sunsetMode ??= defaultSettings.sunsetMode;
  overexposureThreshold ??= defaultSettings.overexposureThreshold;

  // 4. Update ALL UI elements to reflect the loaded state.
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();

  // Initial redraw
  debugMessage('Loaded state. Forcing redraw...');
  redraw();
}

function draw() {
  // Use blendMode(BLEND) to draw the background normally
  blendMode(BLEND);
  background(0);

  // Switch to blendMode(ADD) to create the glow effect
  blendMode(ADD);

  // Corrected logic: if sbsMode is true, render side-by-side. Otherwise, render single.
  if (sbsMode) {
    // Side-by-side mode: draw two panels with adjustable distance
    let halfWidth = width / 2;
    push();
    translate(halfWidth / 2 - sbsDistance / 2, height / 2);
    scale(zoom);
    renderKaleidoscope();
    pop();

    push();
    translate(halfWidth + halfWidth / 2 + sbsDistance / 2, height / 2);
    scale(zoom);
    renderKaleidoscope();
    pop();
  } else {
    // Single panel mode: center the drawing
    push();
    translate(width / 2, height / 2);
    scale(zoom);
    renderKaleidoscope();
    pop();
  }

  time += animSpeed;
}

function handleDraw(x, y, button) {
  let currentX, currentY;

  // Corrected logic: if sbsMode is true, handle SBS drawing. Otherwise, handle single.
  if (sbsMode) {
    // Side-by-side mode: only allow drawing on the left half
    let halfWidth = width / 2;
    if (x > halfWidth) return;
    currentX = (x - (halfWidth / 2 - sbsDistance / 2)) / zoom;
    currentY = (y - height / 2) / zoom;
  } else {
    // Single panel mode: map input to entire canvas, accounting for zoom
    currentX = (x - width / 2) / zoom;
    currentY = (y - height / 2) / zoom;
  }

  if (positions.length === 0 ||
      dist(currentX, currentY, positions[positions.length - 1][0], positions[positions.length - 1][1]) > minDist) {
    positions.push([currentX, currentY, button]);
  }
}

// Extract your existing kaleidoscope loop into a helper
function renderKaleidoscope() {
  for (let i = 0; i < numSymmetry; i++) {
    push();
    rotate(TWO_PI * i / numSymmetry);
    drawTetrahedronLine();
    pop();

    if (numSymmetry > 1) {
      push();
      rotate(TWO_PI * i / numSymmetry);
      scale(1, -1);
      drawTetrahedronLine();
      pop();
    }
  }
}

// NEW HELPER: Checks if the mouse is currently over a UI element
function isUIElementUnderMouse() {
  const el = document.elementFromPoint(mouseX, mouseY);
  if (!el) return false;
  const tag = el.tagName.toLowerCase();
  return tag === 'button' || tag === 'input' || el.closest('.controls-container') || el.closest('.mobile-sliders') || el.closest('.param-table');
}

function drawTetrahedronLine() {
  for (let i = 0; i < positions.length; i++) {
    let [x, y, button] = positions[i];
    let pulseValue = getDistancePulse(x, y, time);

    let hue, saturation, brightness, alpha;

    // Determine the color palette based on sunsetMode
    const colorHues = sunsetMode ? defaultSettings.sunsetHues : defaultSettings.nonGreenHues;

    if (button === RIGHT) {
      hue = 0;
      saturation = 0;
      brightness = 70 + 30 * sin(time * 200 * animSpeed + i * 0.4);
      alpha = 0.5 + 0.4 * sin(time * 300 * animSpeed + i * 0.5);
    } else {
      if (dynamicHue) {
        // Dynamic cycling through selected hues
        let progress = ((time * colorShiftSpeed + i * 10) % 360) / 360;
        let index = Math.floor(progress * colorHues.length);
        let baseHue = colorHues[index % colorHues.length];
        if (hueVariationAmp > 0) {
          const variation = hueVariationAmp * sin(time * 100 * animSpeed + i * 0.5);
          if (baseHue <= 75) {
            hue = Math.max(0, Math.min(75, baseHue + variation));
          } else {
            hue = Math.max(165, Math.min(360, baseHue + variation));
          }
        } else {
          hue = baseHue;
        }
      } else {
        // Static: cycle through selected hues based on point index
        hue = colorHues[i % colorHues.length];
      }
      saturation = 100;
      brightness = 70 + 30 * sin(time * 200 * animSpeed + i * 0.4);
      alpha = 0.5 + 0.4 * sin(time * 300 * animSpeed + i * 0.5);
    }

    brightness = brightness * pulseValue;
    let currentSize = baseSize * pulseValue;

    fill(hue, saturation, brightness, alpha);
    noStroke();
    beginShape();
    vertex(x, y - currentSize / sqrt(3));
    vertex(x - currentSize / 2, y + currentSize / (2 * sqrt(3)));
    vertex(x + currentSize / 2, y + currentSize / (2 * sqrt(3)));
    endShape(CLOSE);
  }
}


function getDistancePulse(x, y, time) {
  // If wave mode is off, just return a fixed pulse value of 1.
  if (waveMode === 'off') {
    return 1;
  }

  // If breathing is off, return 1 as well.
  if (!breathingOn) {
    return 1;
  }

  const d = dist(x, y, 0, 0);
  let direction;
  if (waveMode === 'inward') {
    direction = 1;
  } else if (waveMode === 'outward') {
    direction = -1;
  } else {
    direction = breathingOn ? sin(time * breathingFreq) : 1;
  }
  const pulse = sin(time * waveSpeed + d * waveSpatialFreq * direction);
  return map(pulse, -1, 1, pulseMin, 1);
}

function toggleBreathing() {
  breathingOn = !breathingOn;
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

function toggleNormalDraw() {
  if (numSymmetry === 1) {
    numSymmetry = lastSymmetry || 2;
  } else {
    lastSymmetry = numSymmetry;
    numSymmetry = 1;
  }
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

function toggleSBSMode() {
  sbsMode = !sbsMode;
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

// NEW: Toggle Sunset Mode function
function toggleSunsetMode() {
  sunsetMode = !sunsetMode;
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

function saveToHtmlFile() {
  // Create a state object with all the current settings and drawing data
  const state = {
    positions,
    numSymmetry,
    baseSize,
    animSpeed,
    waveSpeed,
    breathingFreq,
    waveSpatialFreq,
    breathingAmp,
    colorShiftSpeed,
    pulseMin,
    breathingOn,
    minDist,
    waveMode,
    hueVariationAmp,
    dynamicHue,
    sbsMode,
    sbsDistance,
    zoom,
    sunsetMode,
    overexposureThreshold
  };

  const stateStr = JSON.stringify(state);
  const now = new Date();
  const timestamp = now.getFullYear() + '-' +
                    (now.getMonth() + 1).toString().padStart(2, '0') + '-' +
                    now.getDate().toString().padStart(2, '0') + '-' +
                    now.getHours().toString().padStart(2, '0') + '-' +
                    now.getMinutes().toString().padStart(2, '0') + '-' +
                    now.getSeconds().toString().padStart(2, '0');
  const url = window.location.href.split('#')[0] + `#${encodeURIComponent(stateStr)}`;
  const filename = `kaleidoscope-${timestamp}.html`;

  // Create a minimal HTML file content that redirects to the URL
  const fileContent = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Kaleidoscope Drawing Session</title>
  <meta http-equiv="refresh" content="0; url=${url}">
  <style>
    body { font-family: sans-serif; background-color: #111; color: #fff; text-align: center; padding-top: 50px; }
    a { color: #88c0d4; }
  </style>
</head>
<body>
  <p>Loading your Kaleidoscope session...</p>
  <p>If the page doesn't redirect, click this link: <a href="${url}">Load Session</a></p>
</body>
</html>`;

  download(fileContent, filename, 'text/html');
}

function download(data, filename, type) {
  const blob = new Blob([data], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function changeParam(param, delta) {
  switch(param) {
    case 'symmetry':
      if (numSymmetry === 1 && delta === 1) {
        numSymmetry = 2;
      } else {
        numSymmetry = Math.max(1, numSymmetry + delta);
      }
      break;
    case 'size':
      baseSize = Math.max(5, baseSize + delta);
      break;
    case 'animSpeed':
      animSpeed = Math.max(0.001, animSpeed + delta);
      break;
    case 'waveSpeed':
      waveSpeed = Math.max(1, waveSpeed + delta);
      break;
    case 'breathingFreq':
      breathingFreq = Math.max(0.1, breathingFreq + delta);
      break;
    case 'waveSpatialFreq':
      waveSpatialFreq = Math.max(0.01, waveSpatialFreq + delta);
      break;
    case 'breathingAmp':
      breathingAmp = Math.max(10, breathingAmp + delta);
      break;
    case 'colorShiftSpeed':
      colorShiftSpeed = Math.max(10, colorShiftSpeed + delta);
      break;
    case 'pulseMin':
      pulseMin = Math.min(0.9, Math.max(0.1, pulseMin + delta));
      break;
    case 'minDist':
      minDist = Math.max(1, minDist + delta);
      break;
    case 'waveMode':
      // Updated wave modes to include 'off'
      const modes = ['both', 'inward', 'outward', 'off'];
      const currentIndex = modes.indexOf(waveMode);
      waveMode = modes[(currentIndex + 1) % modes.length];
      break;
    case 'hueVariationAmp':
      hueVariationAmp = Math.max(0, Math.min(20, hueVariationAmp + delta));
      break;
    case 'sbsDistance':
      sbsDistance += delta;
      break;
    case 'zoom':
      zoom = Math.max(0.1, zoom + delta);
      break;
    case 'overexposureThreshold':
      overexposureThreshold = Math.max(0.1, Math.min(1.0, overexposureThreshold + delta));
      break;
  }
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

function setParam(param, value) {
  value = parseFloat(value);
  switch(param) {
    case 'symmetry':
      numSymmetry = Math.max(1, value);
      break;
    case 'size':
      baseSize = Math.max(5, value);
      break;
    case 'animSpeed':
      animSpeed = Math.max(0.001, value);
      break;
    case 'waveSpeed':
      waveSpeed = Math.max(1, value);
      break;
    case 'breathingFreq':
      breathingFreq = Math.max(0.1, value);
      break;
    case 'waveSpatialFreq':
      waveSpatialFreq = Math.max(0.01, value);
      break;
    case 'breathingAmp':
      breathingAmp = Math.max(10, value);
      break;
    case 'colorShiftSpeed':
      colorShiftSpeed = Math.max(10, value);
      break;
    case 'pulseMin':
      pulseMin = Math.min(0.9, Math.max(0.1, value));
      break;
    case 'minDist':
      minDist = Math.max(1, value);
      break;
    case 'hueVariationAmp':
      hueVariationAmp = Math.max(0, Math.min(20, value));
      break;
    case 'sbsDistance':
      sbsDistance = value;
      break;
    case 'zoom':
      zoom = Math.max(0.1, value);
      break;
    case 'overexposureThreshold':
      overexposureThreshold = Math.max(0.1, Math.min(1.0, value));
      break;
  }
  updateParamTable();
  updateMobileUI(); // Sync mobile UI after setting param
  redraw();
}

function clearDrawing() {
  positions = [];
  redraw();
}

function resetSettings() {
  numSymmetry = defaultSettings.numSymmetry;
  waveSpeed = defaultSettings.waveSpeed;
  breathingFreq = defaultSettings.breathingFreq;
  breathingAmp = defaultSettings.breathingAmp;
  waveSpatialFreq = defaultSettings.waveSpatialFreq;
  pulseMin = defaultSettings.pulseMin;
  minDist = defaultSettings.minDist;
  baseSize = defaultSettings.baseSize;
  animSpeed = defaultSettings.animSpeed;
  colorShiftSpeed = defaultSettings.colorShiftSpeed;
  breathingOn = true;
  waveMode = defaultSettings.waveMode;
  hueVariationAmp = defaultSettings.hueVariationAmp;
  dynamicHue = defaultSettings.dynamicHue;
  sbsMode = defaultSettings.sbsMode;
  sbsDistance = defaultSettings.sbsDistance;
  zoom = defaultSettings.zoom;
  sunsetMode = defaultSettings.sunsetMode;
  overexposureThreshold = defaultSettings.overexposureThreshold;

  // Sync all UIs to the new default state
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();

  redraw();
}

function updateParamTable() {
  const paramTable = document.getElementById('param-table');
  if (!paramTable) return;

  document.getElementById('sym').textContent = numSymmetry;
  document.getElementById('size').textContent = baseSize;
  document.getElementById('animSpeed').textContent = animSpeed.toFixed(3);
  document.getElementById('waveSpeed').textContent = waveSpeed.toFixed(0);
  document.getElementById('breathingFreq').textContent = breathingFreq.toFixed(1);
  document.getElementById('waveSpatialFreq').textContent = waveSpatialFreq.toFixed(2);
  document.getElementById('breathingAmp').textContent = breathingAmp.toFixed(0);
  document.getElementById('colorShiftSpeed').textContent = colorShiftSpeed.toFixed(0);
  document.getElementById('pulseMin').textContent = pulseMin.toFixed(1);
  document.getElementById('minDist').textContent = minDist.toFixed(0);
  document.getElementById('waveMode').textContent = waveMode.charAt(0).toUpperCase() + waveMode.slice(1);
  document.getElementById('hueVariationAmp').textContent = hueVariationAmp.toFixed(0);
  document.getElementById('dynamicHue').textContent = dynamicHue ? 'ON' : 'OFF';
  document.getElementById('sbsMode').textContent = sbsMode ? 'ON' : 'OFF';
  document.getElementById('sbsDistance').textContent = sbsDistance.toFixed(0);
  document.getElementById('zoom').textContent = zoom.toFixed(2);
  document.getElementById('sunsetMode').textContent = sunsetMode ? 'ON' : 'OFF';
  document.getElementById('overexposureThreshold').textContent = overexposureThreshold.toFixed(2);
}

function updateDesktopButtons() {
  const breathingBtn = document.getElementById('toggleBreathingBtn');
  if (breathingBtn) {
    breathingBtn.textContent = 'Breathing - ' + (breathingOn ? 'ON' : 'OFF') + ' [P]';
  }
  const waveModeBtn = document.getElementById('waveModeBtn');
  if (waveModeBtn) {
    waveModeBtn.textContent = `Wave Mode - ${waveMode.charAt(0).toUpperCase() + waveMode.slice(1)} [O]`;
  }
  const dynamicHueBtn = document.getElementById('dynamicHueBtn');
  if (dynamicHueBtn) {
    dynamicHueBtn.textContent = `Dynamic Hue - ${dynamicHue ? 'ON' : 'OFF'} [J]`;
  }
  const sbsModeBtn = document.getElementById('sbsModeBtn');
  if (sbsModeBtn) {
    sbsModeBtn.textContent = `SBS Mode - ${sbsMode ? 'ON' : 'OFF'} [L]`;
  }
  const sunsetModeBtn = document.getElementById('sunsetModeBtn');
  if (sunsetModeBtn) {
    sunsetModeBtn.textContent = `Sunset Mode - ${sunsetMode ? 'ON' : 'OFF'}`;
  }
}

function updateMobileUI() {
  const mobileSliders = document.getElementById('mobile-sliders');
  if (!mobileSliders) return;

  // Sync sliders to current values
  const sliders = {
    'symmetry': numSymmetry,
    'size': baseSize,
    'animSpeed': animSpeed,
    'waveSpeed': waveSpeed,
    'breathingFreq': breathingFreq,
    'waveSpatialFreq': waveSpatialFreq,
    'breathingAmp': breathingAmp,
    'colorShiftSpeed': colorShiftSpeed,
    'pulseMin': pulseMin,
    'minDist': minDist,
    'hueVariationAmp': hueVariationAmp,
    'sbsDistance': sbsDistance,
    'zoom': zoom,
    'overexposureThreshold': overexposureThreshold
  };

  for (const param in sliders) {
    const input = mobileSliders.querySelector(`input[oninput*="'${param}'"]`);
    const span = document.getElementById(`${param}-value`);
    if (input) {
      input.value = sliders[param];
    }
    if (span) {
      if (param === 'animSpeed') span.textContent = sliders[param].toFixed(3);
      else if (param === 'waveSpatialFreq' || param === 'zoom' || param === 'overexposureThreshold') span.textContent = sliders[param].toFixed(2);
      else if (param === 'breathingFreq' || param === 'pulseMin') span.textContent = sliders[param].toFixed(1);
      else span.textContent = Math.round(sliders[param]);
    }
  }

  // Sync button state
  const mobileNormalBtn = document.getElementById('mobileNormalDrawBtn');
  const mobileBreathingBtn = document.getElementById('mobileBreathingBtn');
  const mobileWaveModeBtn = document.getElementById('mobileWaveModeBtn');
  const mobileDynamicHueBtn = document.getElementById('mobileDynamicHueBtn');
  const mobileSbsBtn = document.getElementById('mobileSbsBtn');
  const mobileSunsetBtn = document.getElementById('mobileSunsetBtn');

  if (mobileNormalBtn) {
    if (numSymmetry === 1) {
      mobileNormalBtn.classList.add('is-on');
    } else {
      mobileNormalBtn.classList.remove('is-on');
    }
  }

  if (mobileBreathingBtn) {
    if (breathingOn) {
      mobileBreathingBtn.classList.add('is-on');
    } else {
      mobileBreathingBtn.classList.remove('is-on');
    }
  }

  // NEW: Update mobile wave mode button text and color
  if (mobileWaveModeBtn) {
    mobileWaveModeBtn.textContent = `Wave ${waveMode.charAt(0).toUpperCase() + waveMode.slice(1)}`;
    mobileWaveModeBtn.classList.remove('is-on', 'wave-in', 'wave-out', 'wave-off');
    switch (waveMode) {
      case 'both':
        mobileWaveModeBtn.classList.add('is-on');
        break;
      case 'inward':
        mobileWaveModeBtn.classList.add('wave-in');
        break;
      case 'outward':
        mobileWaveModeBtn.classList.add('wave-out');
        break;
      case 'off':
        mobileWaveModeBtn.classList.add('wave-off');
        break;
    }
  }

  if (mobileDynamicHueBtn) {
    if (dynamicHue) {
      mobileDynamicHueBtn.classList.add('is-on');
    } else {
      mobileDynamicHueBtn.classList.remove('is-on');
    }
  }

  if (mobileSbsBtn) {
    mobileSbsBtn.textContent = `SBS ${sbsMode ? 'ON' : 'OFF'}`;
    if (sbsMode) {
      mobileSbsBtn.classList.add('is-on');
    } else {
      mobileSbsBtn.classList.remove('is-on');
    }
  }

  if (mobileSunsetBtn) {
    mobileSunsetBtn.textContent = `Sunset ${sunsetMode ? 'ON' : 'OFF'}`;
    if (sunsetMode) {
      mobileSunsetBtn.classList.add('is-on');
    } else {
      mobileSunsetBtn.classList.remove('is-on');
    }
  }
}

function toggleDynamicHue() {
  dynamicHue = !dynamicHue;
  updateParamTable();
  updateDesktopButtons();
  updateMobileUI();
  redraw();
}

// =========================
// Touch/pointer event guards for mobile
// Prevent drawing when interacting with sliders
// =========================
const mobileSlidersEl = document.getElementById('mobile-sliders');

function absorbTouchLikeEvents(e) {
  const tag = e.target.tagName && e.target.tagName.toLowerCase();
  if (tag === 'input' || tag === 'button') {
    resetHideUITimer();
    return;
  }
  e.stopPropagation();
  e.preventDefault();
  resetHideUITimer();
}

['touchstart','touchmove','touchend','pointerdown','pointermove','wheel'].forEach(evt => {
  mobileSlidersEl.addEventListener(evt, absorbTouchLikeEvents, { passive: false });
});
mobileSlidersEl.addEventListener('input', resetHideUITimer);

// Any tap/click on the document (outside sliders) should reveal the button and reset timer
document.addEventListener('pointerdown', (e) => {
  if (!mobileSlidersEl.contains(e.target)) {
    showMobileButton();
    resetHideUITimer();
  }
}, { passive: true });

// =========================
// p5 touch event handlers (FIXED AGAIN)
// =========================
function touchStarted() {
  if (touches.length === 0) return;
  // NEW: Check for UI element at touch point
  const el = document.elementFromPoint(touches[0].x, touches[0].y);
  if (el && (el.tagName.toLowerCase() === 'input' || el.tagName.toLowerCase() === 'button' || el.closest('.mobile-sliders'))) {
    return true; // allow UI interaction, don’t draw
  }
  const button = (touches.length >= 2) ? RIGHT : LEFT;
  handleDraw(touches[0].x, touches[0].y, button);
  return false;
}

function touchMoved() {
  if (touches.length === 0) return;
  // NEW: Check for UI element at touch point
  const el = document.elementFromPoint(touches[0].x, touches[0].y);
  if (el && (el.tagName.toLowerCase() === 'input' || el.tagName.toLowerCase() === 'button' || el.closest('.mobile-sliders'))) {
    return true;
  }
  const button = (touches.length >= 2) ? RIGHT : LEFT;
  handleDraw(touches[0].x, touches[0].y, button);
  return false;
}

function touchEnded() {
  return true; // let normal clicks work
}


// =========================
// p5 mouse event handlers (RE-ADDED)
// =========================
function mousePressed() {
  // Prevent drawing if the mouse is over a UI element
  if (isUIElementUnderMouse()) {
    return true;
  }
  handleDraw(mouseX, mouseY, mouseButton);
  return false; // Prevent default browser behavior
}

function mouseDragged() {
  if (isUIElementUnderMouse()) {
    return true;
  }
  handleDraw(mouseX, mouseY, mouseButton);
  return false;
}


// =========================
// Full-screen logic
// =========================
function toggleFullScreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
}

document.addEventListener('fullscreenchange', () => {
  const desktopUI = document.getElementById('controls-container');
  const paramTable = document.getElementById('param-table');
  const mobileSliders = document.getElementById('mobile-sliders');

  if (document.fullscreenElement) {
    desktopUI.classList.add('hidden');
    paramTable.classList.add('hidden');
    mobileSliders.classList.add('hidden');
  } else {
    // When exiting fullscreen, the UI panels remain hidden.
    // The user can re-engage them with the buttons.
  }
});

// Initial call to sync UI
window.onload = function() {
  setup();
  if (window.innerWidth > 768) {
    // Ensure desktop UI is visible on large screens
    document.getElementById('controls-container').classList.remove('hidden');
    document.getElementById('param-table').classList.remove('hidden');
  } else {
    const mobileSliders = document.getElementById('mobile-sliders');
    mobileSliders.classList.add('hidden');
    showMobileButton();
    resetHideUITimer();
  }
};
</script>
</body>
</html>

