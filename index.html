<!DOCTYPE html>
<html>
<head>
  <title>Kaleidoscope Drawing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: sans-serif;
      color: #fff;
      position: relative;
    }
    canvas {
      display: block;
      /* THIS IS THE CRUCIAL FIX: */
      pointer-events: none;
    }

    /* =========================
       SHARED/EXISTING UI
       ========================= */
    .param-table {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: opacity 0.5s;
      width: 150px;
    }
    .param-table.hidden, .controls-container.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .param-table table {
      border-collapse: collapse;
      width: 100%;
    }
    .param-table th, .param-table td {
      padding: 5px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .param-table th {
      background: rgba(0, 255, 0, 0.1);
      color: #fff;
    }
    .param-table td {
      background: rgba(0, 0, 0, 0.2);
    }
    .controls-container {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 9;
    }
    .controls-container > div {
      pointer-events: auto;
    }
    .controls-bottom-left, .controls-bottom-right {
      position: absolute;
      bottom: 20px;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .controls-bottom-left {
      left: 20px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
    }
    .controls-bottom-right {
      right: 20px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
    }
    .controls-bottom-left button, .controls-bottom-right button, .mobile-sliders button, #play-pause-btn {
      padding: 8px 12px;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.5);
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.3s;
    }
    .controls-bottom-right button {
      min-width: 150px;
    }
    .controls-bottom-left .full-width-btn, .mobile-sliders .full-width-btn {
      grid-column: span 2;
    }

    /* =========================
       MOBILE UI
       ========================= */

    /* Small top-right toggle button (mobile only) */
    .toggle-ui-btn {
      position: absolute;
      /* Top-middle Sliders button */
      left: 50%;
      transform: translateX(-50%);
      top: 10px;
      /* Copy-link button (top-left) */
      left: 10px;
      /* Full-screen toggle (top-right) */
      right: 10px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.5);
      color: #fff;
      border-radius: 6px;
      z-index: 99; /* above everything */
      cursor: pointer;
      font-size: 12px;
      opacity: 0.9;
      transition: opacity 0.25s, transform 0.2s;
      pointer-events: auto;
    }
    .toggle-ui-btn:active { transform: scale(0.98); }
    .toggle-ui-btn.hidden { display: none; }

    /* Mobile sliders panel (compact) */
    .mobile-sliders {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      display: none;        /* default hidden */
      flex-direction: column;
      gap: 8px;
      z-index: 25;          /* below toggle button */
      overflow-y: auto;
      max-height: 48vh;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }
    .mobile-sliders.hidden { display: none; }

    /* Compact slider rows */
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      line-height: 1;
    }
    .slider-container label {
      min-width: 92px;
      text-align: right;
      font-size: 12px;
      opacity: 0.95;
    }
    .slider-container input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #444;
      border-radius: 5px;
      outline: none;
    }
    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: #888;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(255,255,255,0.25);
    }
    .slider-container input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #888;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(255,255,255,0.25);
    }
    .slider-container span {
      min-width: 44px;
      text-align: left;
    }

    /* Hide desktop UI and show mobile button only on small screens */
    @media (max-width: 768px) {
      .controls-container, .param-table {
        display: none;
      }
      .mobile-sliders {
        display: flex; /* will be overridden by .hidden when needed */
      }
      /* The toggle button exists only on mobile */
      .toggle-ui-btn {
        display: block;
      }
    }

    /* On desktop, never show the mobile toggle */
    @media (min-width: 769px) {
      .toggle-ui-btn {
        display: none;
      }
    }
  </style>
</head>
<body>

<div id="debug-message-box" class="debug-message-box" style="position:absolute; top:0; left:0; z-index:50; font-size:11px; padding:4px 6px; color:#9cf;"></div>

<button
    id="copyLinkBtn"
    class="toggle-ui-btn"
    style="top:10px; left:10px; right:auto;"
    onclick="navigator.clipboard.writeText(window.location.href.split('#')[0] + '#' + encodeURIComponent(JSON.stringify({
      positions, numSymmetry, baseSize, animSpeed, waveSpeed, breathingFreq,
      waveSpatialFreq, breathingAmp, colorShiftSpeed, pulseMin, breathingOn,
      minDist, waveMode, hueVariationAmp, dynamicHue
    }))).then(()=>{alert('Link copied!');})">
  Copy Link
</button>

<button
    id="toggleBtn"
    class="toggle-ui-btn"
    style="top:10px; left:50%; transform:translateX(-50%); right:auto;"
    onclick="toggleMobileUI()">
  Sliders
</button>

<button
    id="fullscreenBtn"
    class="toggle-ui-btn"
    style="top:10px; right:10px; left:auto; padding:6px;"
    onclick="toggleFullScreen()"
    title="Full screen">
  &#x26F6;
</button>


<div class="param-table hidden" id="param-table">
  <table>
    <tr><th>Sym</th><td id="sym">6</td></tr>
    <tr><th>Size</th><td id="size">15</td></tr>
    <tr><th>Anim Spd</th><td id="animSpeed">0.030</td></tr>
    <tr><th>Wave Spd</th><td id="waveSpeed">3</td></tr>
    <tr><th>Breath Freq</th><td id="breathingFreq">0.3</td></tr>
    <tr><th>Wave Freq</th><td id="waveSpatialFreq">0.09</td></tr>
    <tr><th>Breath Amp</th><td id="breathingAmp">30</td></tr>
    <tr><th>Color Shift</th><td id="colorShiftSpeed">50</td></tr>
    <tr><th>Pulse Min</th><td id="pulseMin">0.2</td></tr>
    <tr><th>Spacing</th><td id="minDist">1</td></tr>
    <tr><th>Wave Mode</th><td id="waveMode">Both</td></tr>
    <tr><th>Hue Var Amp</th><td id="hueVariationAmp">5</td></tr>
    <tr><th>Dynamic Hue</th><td id="dynamicHue">ON</td></tr>
  </table>
</div>

<div class="controls-container hidden" id="controls-container">
  <div class="controls-bottom-left">
    <button onclick="changeParam('symmetry', -1)">Sym - [U]</button>
    <button onclick="changeParam('symmetry', 1)">Sym + [I]</button>
    <button onclick="changeParam('size', -5)">Size - [D]</button>
    <button onclick="changeParam('size', 5)">Size + [F]</button>
    <button onclick="changeParam('animSpeed', -0.005)">Anim Spd - [T]</button>
    <button onclick="changeParam('animSpeed', 0.005)">Anim Spd + [Y]</button>
    <button onclick="changeParam('waveSpeed', -1)">Wave Spd - [Q]</button>
    <button onclick="changeParam('waveSpeed', 1)">Wave Spd + [W]</button>
    <button onclick="toggleNormalDraw()" class="full-width-btn">Normal Draw - [K]</button>
  </div>
  <div class="controls-bottom-right">
    <button onclick="changeParam('breathingFreq', -0.1)">Breath Freq - [A]</button>
    <button onclick="changeParam('breathingFreq', 0.1)">Breath Freq + [S]</button>
    <button onclick="changeParam('waveSpatialFreq', -0.01)">Wave Freq - [E]</button>
    <button onclick="changeParam('waveSpatialFreq', 0.01)">Wave Freq + [R]</button>
    <button onclick="changeParam('breathingAmp', -10)">Breath Amp - [Z]</button>
    <button onclick="changeParam('breathingAmp', 10)">Breath Amp + [X]</button>
    <button onclick="changeParam('colorShiftSpeed', -10)">Color Shift - [G]</button>
    <button onclick="changeParam('colorShiftSpeed', 10)">Color Shift + [H]</button>
    <button onclick="changeParam('pulseMin', -0.1)">Pulse Min - [V]</button>
    <button onclick="changeParam('pulseMin', 0.1)">Pulse Min + [B]</button>
    <button onclick="changeParam('minDist', -1)">Spacing - [</button>
    <button onclick="changeParam('minDist', 1)">Spacing + ]</button>
    <button onclick="changeParam('hueVariationAmp', -1)">Hue Var - [N]</button>
    <button onclick="changeParam('hueVariationAmp', 1)">Hue Var + [M]</button>
    <button id="dynamicHueBtn" onclick="toggleDynamicHue()" class="full-width-btn">Dynamic Hue - ON [J]</button>
    <button id="waveModeBtn" onclick="changeParam('waveMode', 0)" class="full-width-btn">Wave Mode - Both [O]</button>
    <button id="toggleBreathingBtn" onclick="toggleBreathing()" class="full-width-btn">Breathing - ON [P]</button>
    <button onclick="resetSettings()" class="full-width-btn">Reset - [⌫]</button>
    <button onclick="toggleDesktopUI()" class="full-width-btn">Hide UI - [`]</button>
  </div>
</div>

<div class="mobile-sliders hidden" id="mobile-sliders">
  <div class="slider-container">
    <label>Symmetry</label>
    <input type="range" min="1" max="20" step="1" value="6" oninput="setParam('symmetry', this.value)">
    <span id="symmetry-value">6</span>
  </div>
  <div class="slider-container">
    <label>Size</label>
    <input type="range" min="5" max="50" step="5" value="15" oninput="setParam('size', this.value)">
    <span id="size-value">15</span>
  </div>
  <div class="slider-container">
    <label>Anim Spd</label>
    <input type="range" min="0.001" max="0.1" step="0.005" value="0.03" oninput="setParam('animSpeed', this.value)">
    <span id="animSpeed-value">0.030</span>
  </div>
  <div class="slider-container">
    <label>Wave Spd</label>
    <input type="range" min="1" max="10" step="1" value="3" oninput="setParam('waveSpeed', this.value)">
    <span id="waveSpeed-value">3</span>
  </div>
  <div class="slider-container">
    <label>Breath Freq</label>
    <input type="range" min="0.1" max="1" step="0.1" value="0.3" oninput="setParam('breathingFreq', this.value)">
    <span id="breathingFreq-value">0.3</span>
  </div>
  <div class="slider-container">
    <label>Wave Freq</label>
    <input type="range" min="0.01" max="0.5" step="0.01" value="0.09" oninput="setParam('waveSpatialFreq', this.value)">
    <span id="waveSpatialFreq-value">0.09</span>
  </div>
  <div class="slider-container">
    <label>Breath Amp</label>
    <input type="range" min="10" max="100" step="10" value="30" oninput="setParam('breathingAmp', this.value)">
    <span id="breathingAmp-value">30</span>
  </div>
  <div class="slider-container">
    <label>Color Shift</label>
    <input type="range" min="10" max="100" step="10" value="50" oninput="setParam('colorShiftSpeed', this.value)">
    <span id="colorShiftSpeed-value">50</span>
  </div>
  <div class="slider-container">
    <label>Pulse Min</label>
    <input type="range" min="0.1" max="0.9" step="0.1" value="0.2" oninput="setParam('pulseMin', this.value)">
    <span id="pulseMin-value">0.2</span>
  </div>
  <div class="slider-container">
    <label>Spacing</label>
    <input type="range" min="1" max="10" step="1" value="1" oninput="setParam('minDist', this.value)">
    <span id="minDist-value">1</span>
  </div>
  <div class="slider-container">
    <label>Hue Var Amp</label>
    <input type="range" min="0" max="20" step="1" value="5" oninput="setParam('hueVariationAmp', this.value)">
    <span id="hueVariationAmp-value">5</span>
  </div>

  <div class="slider-container">
    <button class="full-width-btn" onclick="toggleDynamicHue()">Toggle Dynamic Hue</button>
  </div>
  <div class="slider-container">
    <button class="full-width-btn" onclick="changeParam('waveMode', 0)">Toggle Wave Mode</button>
  </div>
  <div class="slider-container">
    <button class="full-width-btn" onclick="toggleBreathing()">Toggle Breathing</button>
  </div>
  <div class="slider-container">
    <button class="full-width-btn" onclick="toggleNormalDraw()">Toggle Normal Draw</button>
  </div>
  <div class="slider-container">
    <button class="full-width-btn" onclick="resetSettings()">Reset</button>
  </div>
  <div class="slider-container">
    <button class="full-width-btn" onclick="toggleMobileUI()">Hide Sliders</button>
  </div>
</div>

<script>
// Prevent right-click context menu unless Ctrl is pressed
document.oncontextmenu = function(event) {
  return event.ctrlKey;
};

// =========================
// Global variables
// =========================
let numSymmetry;
let time = 0;
let positions = [];
let baseSize;
let animSpeed;
let waveSpeed;
let breathingFreq;
let waveSpatialFreq;
let breathingAmp;
let colorShiftSpeed;
let pulseMin;
let breathingOn;
let lastSymmetry;
let minDist;
let isDesktopUIVisible = false;
let isMobileUIVisible = false;
let waveMode;
let hueVariationAmp;
let dynamicHue;

// Mobile auto-hide timer
let hideUITimer = null;

// Default settings
const defaultSettings = {
  numSymmetry: 6,
  waveSpeed: 3,
  breathingFreq: 0.3,
  breathingAmp: 30,
  waveSpatialFreq: 0.09,
  pulseMin: 0.2,
  minDist: 1,
  baseSize: 15,
  animSpeed: 0.03,
  colorShiftSpeed: 50,
  waveMode: 'both',
  hueVariationAmp: 5,
  dynamicHue: true,
  nonGreenHues: [0, 30, 60, 200, 240, 300] // Red, orange, yellow, cyan, blue, purple
};

/* --- Debugging: console only --- */
function debugMessage(msg) {
  console.log(msg); // no more drawing text to canvas
}

/* --- Key handling --- */
document.addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.key.toLowerCase() === 's') {
    event.preventDefault();
    saveToTextFile();
    return;
  }

  if (event.key === 'Delete') {
    positions = [];
    return;
  }

  const key = event.key.toUpperCase();
  switch (key) {
    case 'Q': changeParam('waveSpeed', -1); break;
    case 'W': changeParam('waveSpeed', 1); break;
    case 'A': changeParam('breathingFreq', -0.1); break;
    case 'S': changeParam('breathingFreq', 0.1); break;
    case 'Z': changeParam('breathingAmp', -10); break;
    case 'X': changeParam('breathingAmp', 10); break;
    case 'E': changeParam('waveSpatialFreq', -0.01); break;
    case 'R': changeParam('waveSpatialFreq', 0.01); break;
    case 'D': changeParam('size', -5); break;
    case 'F': changeParam('size', 5); break;
    case 'T': changeParam('animSpeed', -0.005); break;
    case 'Y': changeParam('animSpeed', 0.005); break;
    case 'G': changeParam('colorShiftSpeed', -10); break;
    case 'H': changeParam('colorShiftSpeed', 10); break;
    case 'V': changeParam('pulseMin', -0.1); break;
    case 'B': changeParam('pulseMin', 0.1); break;
    case '[': changeParam('minDist', -1); break;
    case ']': changeParam('minDist', 1); break;
    case 'U': changeParam('symmetry', -1); break;
    case 'I': changeParam('symmetry', 1); break;
    case 'N': changeParam('hueVariationAmp', -1); break;
    case 'M': changeParam('hueVariationAmp', 1); break;
    case 'J': toggleDynamicHue(); break;
    case 'O': changeParam('waveMode', 0); break;
    case 'P': toggleBreathing(); break;
    case '`':
      toggleDesktopUI();
      toggleMobileUI();
      break;
    case 'BACKSPACE': resetSettings(); break;
  }
});

// =========================
// Desktop UI toggle (unchanged logic; no mobile button involvement)
// =========================
function toggleDesktopUI() {
  const controlsContainer = document.getElementById('controls-container');
  const paramTable = document.getElementById('param-table');
  isDesktopUIVisible = !isDesktopUIVisible;
  if (isDesktopUIVisible) {
    controlsContainer.classList.remove('hidden');
    paramTable.classList.remove('hidden');
  } else {
    controlsContainer.classList.add('hidden');
    paramTable.classList.add('hidden');
  }
}

// =========================
// Mobile UI show/hide + inactivity auto-hide
// =========================
function toggleMobileUI() {
  const mobileSliders = document.getElementById('mobile-sliders');
  const toggleBtn = document.getElementById('toggleBtn');
  isMobileUIVisible = !isMobileUIVisible;
  if (isMobileUIVisible) {
    mobileSliders.classList.remove('hidden');
  } else {
    mobileSliders.classList.add('hidden');
  }
  // Button should be visible when user interacts
  toggleBtn.classList.remove('hidden');
  resetHideUITimer();
}

function showMobileButton() {
  const toggleBtn = document.getElementById('toggleBtn');
  toggleBtn.classList.remove('hidden');
}

function hideMobileUICompletely() {
  const mobileSliders = document.getElementById('mobile-sliders');
  const toggleBtn = document.getElementById('toggleBtn');
  mobileSliders.classList.add('hidden');
  toggleBtn.classList.add('hidden');
  isMobileUIVisible = false;
}

function resetHideUITimer() {
  clearTimeout(hideUITimer);
  hideUITimer = setTimeout(() => {
    hideMobileUICompletely();
  }, 3000); // 3 seconds
}

// =========================
// p5 setup/draw
// =========================
function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  background(0);

  // 1. Try to restore state from URL
  const hash = window.location.hash.substring(1);
  debugMessage('Checking URL...');
  let restored = false;
  if (hash) {
    try {
      const state = JSON.parse(decodeURIComponent(hash));
      if (state.positions) positions = state.positions;
      if (state.numSymmetry !== undefined) numSymmetry = state.numSymmetry;
      if (state.baseSize !== undefined) baseSize = state.baseSize;
      if (state.animSpeed !== undefined) animSpeed = state.animSpeed;
      if (state.waveSpeed !== undefined) waveSpeed = state.waveSpeed;
      if (state.breathingFreq !== undefined) breathingFreq = state.breathingFreq;
      if (state.waveSpatialFreq !== undefined) waveSpatialFreq = state.waveSpatialFreq;
      if (state.breathingAmp !== undefined) breathingAmp = state.breathingAmp;
      if (state.colorShiftSpeed !== undefined) colorShiftSpeed = state.colorShiftSpeed;
      if (state.pulseMin !== undefined) pulseMin = state.pulseMin;
      if (state.breathingOn !== undefined) breathingOn = state.breathingOn;
      if (state.minDist !== undefined) minDist = state.minDist;
      if (state.waveMode !== undefined) waveMode = state.waveMode;
      if (state.hueVariationAmp !== undefined) hueVariationAmp = state.hueVariationAmp;
      if (state.dynamicHue !== undefined) dynamicHue = state.dynamicHue;
      restored = true;
      debugMessage('State loaded from URL!');
    } catch (e) {
      console.error("Failed to parse state from URL:", e);
      debugMessage('ERROR: Could not load state from URL.');
    }
  }

  // 2. If nothing was restored, reset to defaults
  if (!restored) {
    debugMessage('No saved state found. Starting new session.');
    resetSettings();
  }

  // 3. Ensure all variables exist after potential restoration
  numSymmetry ??= defaultSettings.numSymmetry;
  waveSpeed ??= defaultSettings.waveSpeed;
  breathingFreq ??= defaultSettings.breathingFreq;
  breathingAmp ??= defaultSettings.breathingAmp;
  waveSpatialFreq ??= defaultSettings.waveSpatialFreq;
  pulseMin ??= defaultSettings.pulseMin;
  minDist ??= defaultSettings.minDist;
  baseSize ??= defaultSettings.baseSize;
  animSpeed ??= defaultSettings.animSpeed;
  colorShiftSpeed ??= defaultSettings.colorShiftSpeed;
  breathingOn ??= true;
  waveMode ??= defaultSettings.waveMode;
  hueVariationAmp ??= defaultSettings.hueVariationAmp;
  dynamicHue ??= defaultSettings.dynamicHue;

  // Update desktop buttons from state
  const breathingBtn = document.getElementById('toggleBreathingBtn');
  if (breathingBtn) {
    breathingBtn.textContent = 'Breathing - ' + (breathingOn ? 'ON' : 'OFF') + ' [P]';
  }
  const waveModeBtn = document.getElementById('waveModeBtn');
  if (waveModeBtn) {
    waveModeBtn.textContent = `Wave Mode - ${waveMode.charAt(0).toUpperCase() + waveMode.slice(1)} [O]`;
  }
  const dynamicHueBtn = document.getElementById('dynamicHueBtn');
  if (dynamicHueBtn) {
    dynamicHueBtn.textContent = `Dynamic Hue - ${dynamicHue ? 'ON' : 'OFF'} [J]`;
  }

  updateParamTable();

  // Desktop: show desktop UI
  if (window.innerWidth > 768) {
    toggleDesktopUI();
  } else {
    // Mobile: start with sliders hidden, show the button for a moment, then auto-hide
    const mobileSliders = document.getElementById('mobile-sliders');
    mobileSliders.classList.add('hidden');
    showMobileButton();
    resetHideUITimer();
  }

  // Initial redraw
  debugMessage('Loaded state. Forcing redraw...');
  redraw();
}

function draw() {
  background(0);

  if (mouseIsPressed) {
    handleDraw(mouseX, mouseY, mouseButton);
  }

  translate(width / 2, height / 2);

  for (let i = 0; i < numSymmetry; i++) {
    push();
    rotate(TWO_PI * i / numSymmetry);
    drawTetrahedronLine();
    pop();

    if (numSymmetry > 1) {
      push();
      rotate(TWO_PI * i / numSymmetry);
      scale(1, -1);
      drawTetrahedronLine();
      pop();
    }
  }

  time += animSpeed;
}

function handleDraw(x, y, button) {
  let currentX = x - width / 2;
  let currentY = y - height / 2;
  if (positions.length === 0 || dist(currentX, currentY, positions[positions.length - 1][0], positions[positions.length - 1][1]) > minDist) {
    positions.push([currentX, currentY, button]);
  }
}

function drawTetrahedronLine() {
  for (let i = 0; i < positions.length; i++) {
    let [x, y, button] = positions[i];
    let pulseValue = getDistancePulse(x, y, time);

    let hue, saturation, brightness, alpha;
    if (button === RIGHT) {
      hue = 0;
      saturation = 0;
      brightness = 70 + 30 * sin(time * 200 * animSpeed + i * 0.4);
      alpha = 0.5 + 0.4 * sin(time * 300 * animSpeed + i * 0.5);
    } else {
      const hues = defaultSettings.nonGreenHues; // [0, 30, 60, 200, 240, 300]
      if (dynamicHue) {
        // Dynamic cycling through non-green hues
        let progress = ((time * colorShiftSpeed + i * 10) % 360) / 360;
        let index = Math.floor(progress * hues.length);
        let baseHue = hues[index % hues.length];
        if (hueVariationAmp > 0) {
          const variation = hueVariationAmp * sin(time * 100 * animSpeed + i * 0.5);
          if (baseHue <= 75) {
            hue = Math.max(0, Math.min(75, baseHue + variation));
          } else {
            hue = Math.max(165, Math.min(360, baseHue + variation));
          }
        } else {
          hue = baseHue;
        }
      } else {
        // Static: cycle through non-green hues based on point index
        hue = hues[i % hues.length];
      }
      saturation = 100;
      brightness = 70 + 30 * sin(time * 200 * animSpeed + i * 0.4);
      alpha = 0.5 + 0.4 * sin(time * 300 * animSpeed + i * 0.5);
    }

    brightness = brightness * pulseValue;
    let currentSize = baseSize * pulseValue;

    fill(hue, saturation, brightness, alpha);
    noStroke();
    beginShape();
    vertex(x, y - currentSize / sqrt(3));
    vertex(x - currentSize / 2, y + currentSize / (2 * sqrt(3)));
    vertex(x + currentSize / 2, y + currentSize / (2 * sqrt(3)));
    endShape(CLOSE);
  }
}

function getDistancePulse(x, y, time) {
  if (!breathingOn) {
    return 1;
  }
  const d = dist(x, y, 0, 0);
  let direction;
  if (waveMode === 'inward') {
    direction = 1;
  } else if (waveMode === 'outward') {
    direction = -1;
  } else {
    direction = breathingOn ? sin(time * breathingFreq) : 1;
  }
  const pulse = sin(time * waveSpeed + d * waveSpatialFreq * direction);
  return map(pulse, -1, 1, pulseMin, 1);
}

function toggleBreathing() {
  breathingOn = !breathingOn;
  const button = document.getElementById('toggleBreathingBtn');
  if (button) {
    button.textContent = 'Breathing - ' + (breathingOn ? 'ON' : 'OFF') + ' [P]';
  }
  updateParamTable();
  redraw();
}

function toggleNormalDraw() {
  if (numSymmetry === 1) {
    numSymmetry = lastSymmetry || 2;
  } else {
    lastSymmetry = numSymmetry;
    numSymmetry = 1;
  }
  updateParamTable();
  redraw();
}

function saveToTextFile() {
  // Create a state object with all the current settings and drawing data
  const state = {
    positions,
    numSymmetry,
    baseSize,
    animSpeed,
    waveSpeed,
    breathingFreq,
    waveSpatialFreq,
    breathingAmp,
    colorShiftSpeed,
    pulseMin,
    breathingOn,
    minDist,
    waveMode,
    hueVariationAmp,
    dynamicHue
  };

  const stateStr = JSON.stringify(state);
  const now = new Date();
  const timestamp = now.toLocaleString();
  const url = window.location.href.split('#')[0] + `#${encodeURIComponent(stateStr)}`;
  const fileContent = `
Date: ${timestamp}
URL: ${url}

To load your session, copy the URL above and paste it into your browser.
  `;
  download(fileContent, 'kaleidoscope_session.txt', 'text/plain');
}

function download(data, filename, type) {
  const blob = new Blob([data], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function changeParam(param, delta) {
  switch(param) {
    case 'symmetry':
      if (numSymmetry === 1 && delta === 1) {
        numSymmetry = 2;
      } else {
        numSymmetry = Math.max(1, numSymmetry + delta);
      }
      break;
    case 'size':
      baseSize = Math.max(5, baseSize + delta);
      break;
    case 'animSpeed':
      animSpeed = Math.max(0.001, animSpeed + delta);
      break;
    case 'waveSpeed':
      waveSpeed = Math.max(1, waveSpeed + delta);
      break;
    case 'breathingFreq':
      breathingFreq = Math.max(0.1, breathingFreq + delta);
      break;
    case 'waveSpatialFreq':
      waveSpatialFreq = Math.max(0.01, waveSpatialFreq + delta);
      break;
    case 'breathingAmp':
      breathingAmp = Math.max(10, breathingAmp + delta);
      break;
    case 'colorShiftSpeed':
      colorShiftSpeed = Math.max(10, colorShiftSpeed + delta);
      break;
    case 'pulseMin':
      pulseMin = Math.min(0.9, Math.max(0.1, pulseMin + delta));
      break;
    case 'minDist':
      minDist = Math.max(1, minDist + delta);
      break;
    case 'waveMode':
      const modes = ['inward', 'outward', 'both'];
      const currentIndex = modes.indexOf(waveMode);
      waveMode = modes[(currentIndex + 1) % modes.length];
      const waveModeBtn = document.getElementById('waveModeBtn');
      if (waveModeBtn) {
        waveModeBtn.textContent = `Wave Mode - ${waveMode.charAt(0).toUpperCase() + waveMode.slice(1)} [O]`;
      }
      break;
    case 'hueVariationAmp':
      hueVariationAmp = Math.max(0, Math.min(20, hueVariationAmp + delta));
      break;
  }
  updateParamTable();
  redraw();
}

function setParam(param, value) {
  value = parseFloat(value);
  switch(param) {
    case 'symmetry':
      numSymmetry = Math.max(1, value);
      break;
    case 'size':
      baseSize = Math.max(5, value);
      break;
    case 'animSpeed':
      animSpeed = Math.max(0.001, value);
      break;
    case 'waveSpeed':
      waveSpeed = Math.max(1, value);
      break;
    case 'breathingFreq':
      breathingFreq = Math.max(0.1, value);
      break;
    case 'waveSpatialFreq':
      waveSpatialFreq = Math.max(0.01, value);
      break;
    case 'breathingAmp':
      breathingAmp = Math.max(10, value);
      break;
    case 'colorShiftSpeed':
      colorShiftSpeed = Math.max(10, value);
      break;
    case 'pulseMin':
      pulseMin = Math.min(0.9, Math.max(0.1, value));
      break;
    case 'minDist':
      minDist = Math.max(1, value);
      break;
    case 'hueVariationAmp':
      hueVariationAmp = Math.max(0, Math.min(20, value));
      break;
  }
  updateParamTable();
  // Update mobile readout spans
  const valueSpanId = (param === 'symmetry') ? 'symmetry-value' : (param + '-value');
  const valueSpan = document.getElementById(valueSpanId);
  if (valueSpan) {
    if (param === 'animSpeed') valueSpan.textContent = value.toFixed(3);
    else if (param === 'waveSpatialFreq') valueSpan.textContent = value.toFixed(2);
    else if (param === 'breathingFreq' || param === 'pulseMin') valueSpan.textContent = value.toFixed(1);
    else valueSpan.textContent = Math.round(value);
  }
  redraw();
}

function resetSettings() {
  numSymmetry = defaultSettings.numSymmetry;
  waveSpeed = defaultSettings.waveSpeed;
  breathingFreq = defaultSettings.breathingFreq;
  breathingAmp = defaultSettings.breathingAmp;
  waveSpatialFreq = defaultSettings.waveSpatialFreq;
  pulseMin = defaultSettings.pulseMin;
  minDist = defaultSettings.minDist;
  baseSize = defaultSettings.baseSize;
  animSpeed = defaultSettings.animSpeed;
  colorShiftSpeed = defaultSettings.colorShiftSpeed;
  breathingOn = true;
  waveMode = defaultSettings.waveMode;
  hueVariationAmp = defaultSettings.hueVariationAmp;
  dynamicHue = defaultSettings.dynamicHue;
  positions = []; // Also reset the drawing positions

  const breathingBtn = document.getElementById('toggleBreathingBtn');
  if (breathingBtn) breathingBtn.textContent = 'Breathing - ON [P]';
  const waveModeBtn = document.getElementById('waveModeBtn');
  if (waveModeBtn) waveModeBtn.textContent = `Wave Mode - ${waveMode.charAt(0).toUpperCase() + waveMode.slice(1)} [O]`;
  const dynamicHueBtn = document.getElementById('dynamicHueBtn');
  if (dynamicHueBtn) dynamicHueBtn.textContent = `Dynamic Hue - ${dynamicHue ? 'ON' : 'OFF'} [J]`;

  updateParamTable();

  // Sync mobile sliders to defaults if present
  const mobileSliders = document.getElementById('mobile-sliders');
  if (mobileSliders) {
    mobileSliders.querySelectorAll('input[type="range"]').forEach(input => {
      const oninputAttr = input.getAttribute('oninput');
      const match = oninputAttr && oninputAttr.match(/'(.*?)'/);
      if (!match) return;
      const param = match[1];
      const val = defaultSettings[param] ?? input.value;
      input.value = val;
      const spanId = (param === 'symmetry') ? 'symmetry-value' : (param + '-value');
      const valueSpan = document.getElementById(spanId);
      if (valueSpan) {
        if (param === 'animSpeed') valueSpan.textContent = parseFloat(val).toFixed(3);
        else if (param === 'waveSpatialFreq') valueSpan.textContent = parseFloat(val).toFixed(2);
        else if (param === 'breathingFreq' || param === 'pulseMin') valueSpan.textContent = parseFloat(val).toFixed(1);
        else valueSpan.textContent = Math.round(val);
      }
    });
  }

  redraw();
}

function updateParamTable() {
  const paramTable = document.getElementById('param-table');
  if (!paramTable) return;

  document.getElementById('sym').textContent = numSymmetry;
  document.getElementById('size').textContent = baseSize;
  document.getElementById('animSpeed').textContent = animSpeed.toFixed(3);
  document.getElementById('waveSpeed').textContent = waveSpeed.toFixed(0);
  document.getElementById('breathingFreq').textContent = breathingFreq.toFixed(1);
  document.getElementById('waveSpatialFreq').textContent = waveSpatialFreq.toFixed(2);
  document.getElementById('breathingAmp').textContent = breathingAmp.toFixed(0);
  document.getElementById('colorShiftSpeed').textContent = colorShiftSpeed.toFixed(0);
  document.getElementById('pulseMin').textContent = pulseMin.toFixed(1);
  document.getElementById('minDist').textContent = minDist.toFixed(0);
  document.getElementById('waveMode').textContent = waveMode.charAt(0).toUpperCase() + waveMode.slice(1);
  document.getElementById('hueVariationAmp').textContent = hueVariationAmp.toFixed(0);
  document.getElementById('dynamicHue').textContent = dynamicHue ? 'ON' : 'OFF';
}

// =========================
// Touch/pointer event guards for mobile
// Prevent drawing when interacting with sliders
// =========================
const mobileSlidersEl = document.getElementById('mobile-sliders');

function absorbTouchLikeEvents(e) {
  const tag = e.target.tagName && e.target.tagName.toLowerCase();
  if (tag === 'input' || tag === 'button') {
    resetHideUITimer();
    return;
  }
  e.stopPropagation();
  e.preventDefault();
  resetHideUITimer();
}

['touchstart','touchmove','touchend','pointerdown','pointermove','wheel'].forEach(evt => {
  mobileSlidersEl.addEventListener(evt, absorbTouchLikeEvents, { passive: false });
});
mobileSlidersEl.addEventListener('input', resetHideUITimer);

// Any tap/click on the document (outside sliders) should reveal the button and reset timer
document.addEventListener('pointerdown', (e) => {
  if (!mobileSlidersEl.contains(e.target)) {
    showMobileButton();
    resetHideUITimer();
  }
}, { passive: true });

// =========================
// p5 touch event handlers (existing, with fix)
// =========================
function touchStarted(event) {
  const tag = event.target.tagName.toLowerCase();
  if (tag === 'button' || event.target.closest('.slider-container')) {
    return true; // allow the browser to fire the click
  }
  // otherwise it’s a canvas touch:
  if (touches.length === 0) return;
  const button = (touches.length >= 2) ? RIGHT : LEFT;
  handleDraw(touches[0].x, touches[0].y, button);
  return false;
}

function touchMoved(event) {
  const tag = event.target.tagName.toLowerCase();
  if (tag === 'button' || event.target.closest('.slider-container')) {
    return true;
  }
  if (touches.length === 0) return;
  const button = (touches.length >= 2) ? RIGHT : LEFT;
  handleDraw(touches[0].x, touches[0].y, button);
  return false;
}
function touchEnded() {
  return false;
}

// =========================
// Hue toggles
// =========================
function toggleDynamicHue() {
  dynamicHue = !dynamicHue;
  const button = document.getElementById('dynamicHueBtn');
  if (button) button.textContent = `Dynamic Hue - ${dynamicHue ? 'ON' : 'OFF'} [J]`;
  updateParamTable();
  redraw();
}

// =========================
// Full-screen logic
// =========================
function toggleFullScreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
}

document.addEventListener('fullscreenchange', () => {
  const desktopUI = document.getElementById('controls-container');
  const paramTable = document.getElementById('param-table');
  const mobileSliders = document.getElementById('mobile-sliders');

  if (document.fullscreenElement) {
    desktopUI.classList.add('hidden');
    paramTable.classList.add('hidden');
    mobileSliders.classList.add('hidden');
  } else {
    // When exiting fullscreen, the UI panels remain hidden.
    // The user can re-engage them with the buttons.
  }
});
</script>
</body>
</html>
